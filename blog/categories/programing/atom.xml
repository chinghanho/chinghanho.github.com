<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programing | @ChingHanHo]]></title>
  <link href="http://blog.chh.tw/blog/categories/programing/atom.xml" rel="self"/>
  <link href="http://blog.chh.tw/"/>
  <updated>2015-10-01T00:37:07+08:00</updated>
  <id>http://blog.chh.tw/</id>
  <author>
    <name><![CDATA[Ching-Han Ho]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Zepto + Velocity 無縫取代 jQuery 更輕巧]]></title>
    <link href="http://blog.chh.tw/posts/using-zepto-replace-jquery/"/>
    <updated>2015-10-01T00:26:00+08:00</updated>
    <id>http://blog.chh.tw/posts/using-zepto-replace-jquery</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/fKcLfP4rJK5syiKv-cfmDYlbdC0_dV8sAdyQfYM3DxZW76knVkgxFsMC4sWsBpaN_27emoOHF504CNpmSDn0rnlDG2Eu1vw6RNowi18owUxdnBYaotT3hz2BIWnrQioS-tfQfOU4iDNAss3pzDKuNOPmSLWjNVP-zQrZJhZOK1Xf78TU9GdCSKnIApESyUZ777gjz7LC5PKw9Yk_NcNr8GCrKRsd7cCQciMf_sSmmZ1sqWKRcIAVWdt-B7_5fV9nW4vNfBYkFvJCI-BaIC_KmR-KPiVMUHi7y4hMzW1DmT4uzAJwfKIk3tvjWW6pEe345hE3R0nxqq-y0apP64DcndcDHFq16S1KqW465nsZRwvg6412LAjzp1cVM_XEimA9NekxAlTC1u89PNLyALrNtaaNRsAsj02D43lSFKu0gEKGMdAl23BhXkBtL-khwLYgoKWCbRkvZ7eznqnONx7zyGxxbNNU48Rn5NLDhw74Bxr0Xy72I1ROoGjm7E22V5-5BSl3CbsBAgczJ-fxCgxHzYWsmJpdqAIA6DVFmD5A8Vk=w690" alt="zeptojs" /></p>

<p>Zepto 是個跟 jQuery API 相容的套件，但是非常輕巧。</p>

<p>jQuery 1.11.2 不壓縮 278KB，壓縮後是 94.8KB。儘管 jQuery 2.0 比 jQuery 1.11 減少了 12% 的體積大小，仍然是個 200KB 級的套件。而 Zepto 不壓縮 56KB，壓縮後大約是 24.5KB，比 jQuery 平均小了 74%！</p>

<p>Zepto 極其輕巧的秘訣在於它預設只有 jQuery 最關鍵的幾個核心功能，並且用友善的模組化設計，保持每個功能能夠輕易地被擴充。</p>

<h2>擴充 animate 模組</h2>

<p>jQuery 的 <code>animate</code> 效能不是很好，上次在製作公司官網作品牆，讓圖片載完進行 <code>fadeIn</code> 的效果，造成 FPS 低到明顯感受到 lag。</p>

<p>通常需要用到大量的動態視覺效果的首選是 GreenSock 所提供的 TweenMax（344KB）。如果只是需要用來取代 jQuery 的 <code>animate</code> 操作 DOM 的動態效果，那麼能夠跟 jQuery 無縫整合的 Velocity（215KB）有更好的條件。Velocity 優點是效能高，體積比較小，也能夠相容 jQuery API。</p>

<p>Zepto 因為模組化設計的關係，預設是不包括 <code>animate</code> 這個方法的，因此便可以改用 Velocity 來擴充。</p>

<p>外部網站參考：</p>

<ul>
<li><a href="http://zeptojs.com/">Zepto 的專案網站</a></li>
<li><a href="http://julian.com/research/velocity/">Velocity 的專案網站</a></li>
<li><a href="https://greensock.com/tweenmax">TweenMax 的專案網站</a></li>
</ul>


<h2>瀏覽器相容性</h2>

<p>jQuery 2.0 開始就直接放棄 IE 9 以下的瀏覽器，Zepto 更狠直接跳到 IE 10+；而 Velocity 則是不支援 IE 8 以下，所以能不能使用 Zepto + Velocity 這個組合要先觀察一下產品的目標使用群。</p>

<p>如果打算支援 IE 8，還是去用 jQuery 1.11.3 吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9 個存取硬體裝置的 Javascript API]]></title>
    <link href="http://blog.chh.tw/posts/9-javascript-apis-accessing-device-sensors/"/>
    <updated>2015-08-30T17:09:00+08:00</updated>
    <id>http://blog.chh.tw/posts/9-javascript-apis-accessing-device-sensors</id>
    <content type="html"><![CDATA[<p>原生 HTML5 和 Javascript API 可以直接從瀏覽器存取硬體組件和感測器。這裏的硬體裝置主要是指手機。</p>

<h3>點擊連結傳送簡訊</h3>

<p>``` html
<a href="tel:0912345678">打給我！</a></p>

<!-- Android -->


<p><a href="sms:0912345678?body=你到哪了？">傳簡訊給我！</a></p>

<!-- iOS -->


<p><a href="sms:0912345678&amp;body=你到哪了？">傳簡訊給我！</a>
```</p>

<p>延伸資料：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/6480462/how-to-pre-populate-the-sms-body-text-via-an-html-link">How to pre-populate the sms body text via an html link - StackOverflow</a></li>
</ul>


<h3>地理定位 API</h3>

<p>``` js
if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(function (position) {</p>

<pre><code>var whereareyou = position.coords.latitude + ' ,' + position.coords.longitude
alert(whereareyou)
</code></pre>

<p>  })
}
```</p>

<h3>裝置方向與裝置體感 API</h3>

<p>這兩個功能是建立在裝置的陀螺儀和指南針感測器上，它能夠傳回目前裝置的旋轉角度，以及三個維度。</p>

<p>``` js
if (window.DeviceOrientationEvent) {
  window.addEventListener('deviceorientation', function(event) {</p>

<pre><code>// gamma 是左到右傾斜的角度
// beta  是前到後傾斜的角度
// alpha 是裝置面向在指南針方位上的角度
document.body.innerHTML = event.gamma + ' ,' + event.beta + ' ,' + event.alpha
</code></pre>

<p>  }, false)
}
```</p>

<p>有了裝置體感的 API，也可以做出搖一搖復原輸入的功能。</p>

<p>``` js
if (window.DeviceMotionEvent) {
  window.addEventListener('devicemotion', function(evnet) {</p>

<pre><code>document.body.innerHTML = evnet.acceleration.x + '&lt;br/&gt;' + evnet.acceleration.y + '&lt;br/&gt;' + evnet.acceleration.z

// 加速感測
console.log(evnet.acceleration.x)
console.log(evnet.acceleration.y)
console.log(evnet.acceleration.z)

// 加速感測包括重力參數
console.log(evnet.accelerationIncludingGravity.x)
console.log(evnet.accelerationIncludingGravity.y)
console.log(evnet.accelerationIncludingGravity.z)

// 旋轉率
console.log(evnet.rotationRate.alpha)
console.log(evnet.rotationRate.beta)
console.log(evnet.rotationRate.gamma)
</code></pre>

<p>  }, false)
}
```</p>

<p>延伸資料：</p>

<ul>
<li><a href="https://developers.google.com/web/fundamentals/device-access/device-orientation/dev-motion?hl=zh-tw">裝置動作 - Web Fundamentals</a></li>
<li><a href="https://developers.google.com/web/fundamentals/device-access/device-orientation/?hl=zh-tw">裝置定向 - Web Fundamentals</a></li>
</ul>


<h3>震動馬達</h3>

<p>目前只支援 Android 的 Chrome 以及 Opera、Firefox，iOS 尚不支援。</p>

<p><code>js
var btn = document.getElementById('btn')
var vibrate = navigator.vibrate || navigator.mozVibrate || navigator.webkitVibrate
btn.addEventListener('click', function (event) {
  vibrate(1000)
})
</code></p>

<p>延伸資料：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate">Navigator.vibrate() - MDN</a></li>
</ul>


<h3>剩餘電力管理</h3>

<p>``` js
var battery = navigator.battery || navigator.webkitBattery || navigator.mozBattery</p>

<p>function log(<em>battery) {
  document.body.innerHTML = '目前電力剩下：' + (</em>battery.level * 100) + '%'
  _battery.addEventListener('chargingchange', function() {</p>

<pre><code>alert('開始充電！')
</code></pre>

<p>  }, false)
}</p>

<p>if (navigator.getBattery) {
  navigator.getBattery().then(log)
} else if (battery) {
  log(battery)
}
```</p>

<h3>亮度感測器</h3>

<p>目前只有 Firefox 支援這個 API。</p>

<p><code>js
if ('ondevicelight' in window) {
  window.addEventListener("devicelight", function (event) {
  // 回傳的是亮度單位 lux
  console.log(event.value + " lux")
  })
}
</code></p>

<h3>近距離感測 API</h3>

<p>這個也是只有 Firefox 支援。</p>

<p>``` js
if('ondeviceproximity' in window) {
  // Fired when object is in the detection zone
  window.addEventListener('deviceproximity', function (event) {</p>

<pre><code>  // Object distance in centimeters
  console.log(event.value + " centimeters")
})
</code></pre>

<p>} else {
  console.log("deviceproximity not supported")
}</p>

<p>if('ondeviceproximity' in window){
  // Fired when object is in the detection zone
  window.addEventListener('userproximity', function (event) {</p>

<pre><code>if(event.near == true) {
  console.log("Object is near")
} else {
  console.log("Object is far")
}
</code></pre>

<p>  })
} else {
  console.log("userproximity not supported")
}
```</p>

<hr />

<p>參考：</p>

<ul>
<li><a href="http://www.webondevices.com/9-javascript-apis-accessing-device-sensors/">9 JavaScript APIs accessing Device Hardware</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[io.js 1.1 VS node.js 0.12.0 VS node.js 0.10.36]]></title>
    <link href="http://blog.chh.tw/posts/iojs-nodejs-performance/"/>
    <updated>2015-02-10T23:37:00+08:00</updated>
    <id>http://blog.chh.tw/posts/iojs-nodejs-performance</id>
    <content type="html"><![CDATA[<p>這篇文章不是要做深入的效能評比，只是最近 node.js v0.12.0 正式版釋出，又剛好人品很好地用 io.js 1.1 把專案建起來了，乾脆就在本機上做一下 node.js 新舊版和現在很熱的 io.js 效能紀錄。圖有點小，要嘛自己想辦法放大，要嘛就直接看結論吧！XD</p>

<h3>Page 1</h3>

<p><img src="https://lh3.googleusercontent.com/-AWI4LN6fELs/VNomvCU_iMI/AAAAAAAAIKs/Im1igPcG3EI/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.28.59%2BPM.png" alt="node.js v0.12.0 page1" /></p>

<p>node.js v0.12.0 TTFB 1.36s。</p>

<p><img src="https://lh6.googleusercontent.com/-tl-PFTsvs-0/VNomy_t_IkI/AAAAAAAAILU/YRiVxSVD5Dc/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.34.28%2BPM.png" alt="io.js v1.1.0 page1" /></p>

<p>io.js v1.1.0 TTFB 1.21s。</p>

<p><img src="https://lh4.googleusercontent.com/-pJ4XM3ov8v4/VNomx2fPf-I/AAAAAAAAILE/RxH-DOoQygg/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.30.32%2BPM.png" alt="node.js v0.10.36 page1" /></p>

<p>node.js v0.10.36 TTFB 603ms。</p>

<!-- more -->


<h3>Page 2</h3>

<p><img src="https://lh4.googleusercontent.com/-5LGXJ2DInfM/VNomvEBYaQI/AAAAAAAAIK0/UyWZldWsB-4/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.29.22%2BPM.png" alt="node.js v0.12.0 page2" /></p>

<p>node.js v0.12.0 TTFB 910ms。</p>

<p><img src="https://lh3.googleusercontent.com/-CePlsRGHndI/VNomzP3ZMzI/AAAAAAAAILc/YlkhDkjRHAY/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.34.49%2BPM.png" alt="io.js v1.1.0 page2" /></p>

<p>io.js v1.1.0 TTFB 776ms。</p>

<p><img src="https://lh5.googleusercontent.com/-AemhYmtokBw/VNomx8aIBMI/AAAAAAAAILg/3GBjTwsTs1w/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.30.43%2BPM.png" alt="node.js v0.10.36 page2" /></p>

<p>node.js v0.10.36 TTFB 604ms。</p>

<h3>Page 3</h3>

<p><img src="https://lh3.googleusercontent.com/-sbjgcsYBKEI/VNomvAQ99yI/AAAAAAAAIKw/1kKSgNjzysw/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.29.37%2BPM.png" alt="node.js v0.12.0 page3" /></p>

<p>node.js v0.12.0 TTFB 221ms。</p>

<p><img src="https://lh4.googleusercontent.com/-D1D5stJUzPg/VNomxwPjWOI/AAAAAAAAILI/Zj_XEEIcOxs/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.30.51%2BPM.png" alt="node.js v0.10.36 page3" /></p>

<p>io.js v1.1.0 TTFB 217ms。</p>

<p><img src="https://lh3.googleusercontent.com/-ZnrOiohW9VU/VNomzm0vZCI/AAAAAAAAILk/cT8R99I1tJc/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.35.08%2BPM.png" alt="io.js v1.1.0 page3" /></p>

<p>node.js v0.10.36 TTFB 150ms。</p>

<h3>結論</h3>

<p>每個頁面我都土法重複 reload 過好幾次，大概抓的數字是看到的平均值，想說這樣的測試太土法了，沒參考性，但是三個頁面的測試結果彼此比較後都很相像，所以應該可以說明什麼了吧！</p>

<ul>
<li>node.js v0.12.0 TTFB 1.36s +0%</li>
<li>io.js v1.1.0 TTFB 1.21s +12%</li>
<li>node.js v0.10.36 TTFB 603ms +126%</li>
</ul>


<p>頁面一舊版 node.js v0.10.36 比其他兩頁都快得多！跟 io.js v1.1.0 比起來也快了至少 100%。</p>

<ul>
<li>node.js v0.12.0 TTFB 910ms +0%</li>
<li>io.js v1.1.0 TTFB 776ms +17%</li>
<li>node.js v0.10.36 TTFB 604ms +51%</li>
</ul>


<p>頁面二也是 node.js v0.10.36 最快。</p>

<ul>
<li>node.js v0.12.0 TTFB 221ms +0%</li>
<li>io.js v1.1.0 TTFB 217ms +1.8%</li>
<li>node.js v0.10.36 TTFB 150ms +47%</li>
</ul>


<p>頁面三其實都相差不遠，但 node.js v0.10.36 仍然反應最快。</p>

<p>結論就是……等網站上到遠端 server 之後再來測一次真實網路環境下的 TTFB 吧！以目前在本機測試的結果，還沒有很想更新到 node.js v0.12.0，而且以<a href="http://blog.chh.tw/posts/what-is-iojs-nodejs-forking/">現在這局勢</a>看來 io.js 勢頭很高，再過一段時間來評估直接把專案跳去改用 io.js 算了。:p</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node 樣版引擎評估：Jade、Handlebars]]></title>
    <link href="http://blog.chh.tw/posts/node-template-engine-jade-vs-handlebars/"/>
    <updated>2014-11-29T01:38:00+08:00</updated>
    <id>http://blog.chh.tw/posts/node-template-engine-jade-vs-handlebars</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/-aa-cbFoMPDs/VHi1FfBlM-I/AAAAAAAAIJM/T6wEE0RlEtQ/w640-h201-no/Screen%2BShot%2B2014-11-29%2Bat%2B1.44.09%2BAM.png" alt="" /></p>

<h2>短文版</h2>

<p>用 jade。</p>

<h2>長文版</h2>

<p>因為這個專案效能不會是評估重點，語法設計、擴充性、使用彈性會是比較在意的部分。</p>

<p>活在樣版引擎這個群雄割據的戰國時代實在太多選擇，從各方的評論和簡略地掃描文件上的語法特性，挑出以下幾個我比較喜歡的：</p>

<ul>
<li><a href="https://github.com/tj">TJ</a> 早期樣版引擎代表作 <a href="https://github.com/tj/ejs/">ejs</a></li>
<li>以及 TJ 後來的 <a href="https://github.com/jadejs/jade">jade</a></li>
<li>還有 <a href="https://github.com/wycats">wycats</a>（<a href="http://yehudakatz.com/">Yehuda Katz</a>）的 <a href="https://github.com/wycats/handlebars.js">handlebars</a></li>
</ul>


<p>TJ 當初設計 <a href="http://expressjs.com/">Express</a> 承襲 Ruby micro-framework <a href="http://www.sinatrarb.com/">Sinatra</a> 的設計理念，ejs 好像是因應而生（？），從 ejs 語法上面可以看到非常多 Ruby 樣版引擎 ERb 的影子，對我來說是最「友善」的。不過 TJ 另創 jade 樣版引擎加上投奔 Go 世界以後，ejs 的活躍程度越來越低，從今年 5 月之後就再也沒有更新過了。</p>

<p>我向來都會先以「社群活躍度」來評量一個程式專案計畫可靠度，jade 貢獻者在 Github 上成立 <a href="https://github.com/jadejs">jadejs</a> 組織來維護專案，長久來看蠻可靠的。而 handlebars 在 Github 上也廣受 Javascript 開發者歡迎，所以最後我就拿這兩套樣版引擎來比較，以下是值得提出來講的部分。</p>

<p>（再強調一次好了：語法設計、擴充性、使用彈性是我比較在意的項目）</p>

<!-- more -->


<h3>Layouts</h3>

<p>寫過 Rails 後就很喜歡那種把不同 controller actions 的 view，跟 layouts 拆得乾乾淨淨的做法。這點 handlebars 可以做到，也是我最喜歡的一點，jade 必須在每一個 view 裡面寫上重複的 code，來表示外層的 layout：</p>

<p>``` jade
extends layout</p>

<p>block content
  h1= post.title
```</p>

<p>把內容的部分宣告成 block，然後套進 layout 裏去。這也不是大缺點啦，block 寫法可以讓 view 不同區塊使用上更有彈性，但這就很考驗 block 的拆分功力了，不然真的會很容易寫出大量讓人崩潰的縮進層級。</p>

<h3>Partials</h3>

<p>版型上共用的部分一定會拆出來到同個檔案去維護，例如 header、footer、sidebar 之類的，handlebars 要做到這點繞得也太大圈：得先告訴 handlebars 的實例（instance）某個目錄放著我要的 partials 檔案，例如有個 <code>header.hbs</code> partial 放在 <code>/views/partials</code> 目錄下，然後要在 app 主要程式中寫：</p>

<p><code>js
var hbs = require('hbs');
hbs.registerPartial(__dirname, '/views/partials');
</code></p>

<p>才能在 view 裡面帶入 header 這個 partial：<code>{{&gt; header}}</code>。這樣讓檔案的組織非常缺乏彈性，如果 partials 不是在同個地方而是多個目錄，這樣光是找到檔案就很直覺。</p>

<h3>條件判斷</h3>

<p>這個是壓死駱駝最後一根稻草，handlebars 沒有辦法用很簡單的條件判斷式，內建的 <code>#if</code> helper 根本不是拿來寫「條件判斷」的，當初掃描完文件後一定會很自然地寫下 <code>{{#if query === 'list'}}</code>，這樣是不行的喔！</p>

<p><code>#if</code> 頂多拿來判斷物件裡面有東西還是沒東西而已，如果真要寫個「條件判斷」一樣要拆去寫 helper，不管你的是多簡單的判斷。</p>

<h3>結論</h3>

<p>當初 wycats 寫 handlebars 時主要是為了解決前端樣版引擎的問題，所以可以發現很多 server-side 應用的場景 handlebars 都不適用。jade 是 TJ 寫給 Express 用的，讓我最不適應的地方是像 <a href="http://haml.info/">HAML</a> 那樣「縮進崇拜主義」簡化的語法我實在不敢恭維，但顯然目前沒有比「不習慣」更好的理由來阻止我用它，因為 jade 其他面向提供的 solution 確實都能解決問題。</p>

<p>結論就是用 jade！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MongoDB 的 ODM：mongoose 簡單介紹]]></title>
    <link href="http://blog.chh.tw/posts/mongodb-odm-mongoose/"/>
    <updated>2013-09-06T11:11:00+08:00</updated>
    <id>http://blog.chh.tw/posts/mongodb-odm-mongoose</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/-Tdo_5cAPDnk/UilIbkRmleI/AAAAAAAAGqQ/vh6dM2gZvV4/w690-h450-no/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2013-09-06+%25E4%25B8%258A%25E5%258D%258811.12.48.png" alt="mongoose" /></p>

<p><a href="http://mongoosejs.com/">mongoose</a> 是一套給 Node.js 用的 MongoDB ODM，跟常聽到的 ORM 不同的地方只是一些<a href="http://stackoverflow.com/questions/12261866/what-is-the-difference-between-an-orm-and-an-odm">技術名詞定義上的把戲</a>，其實是差不多的意思。</p>

<p>透過 mongoose 可以用包裝過的、更高階的、更直覺的 API 語法，以及模擬 SQL 資料庫 schema-based 的方式，來操作 MongoDB 資料庫。以下是個官方文件給的簡單範例，先建立了一個叫做 Cat 的 Model，<code>model</code> 的第二個參數就是建立 schema 的所在：</p>

<p>``` js
var Cat = mongoose.model('Cat',
  { name: String }
);</p>

<p>var kitty = new Cat({ name: 'Zildjian' });
kitty.save(function (err) {
  if (err) // ...
  console.log('meow');
});
```</p>

<!-- more -->


<h2>與 MongoDB 建立連線</h2>

<p>這裡繼續沿用上一篇文章「<a href="/posts/node-http-vs-connect-vs-express/">Node.js 的 Http vs Connect vs Express</a>」的例子，先把上一篇文章的範例程式碼複製過來，檔案名稱命名為 <em>server.js</em>，下指令執行 <code>node server.js</code> 這樣可以得到一台簡單的伺服器：</p>

<p>``` js
var express = require('express')
  , app     = express()</p>

<p>app.use(express.cookieParser())</p>

<p>app.get('/', function(req, res) {
  console.log(req.cookies)
  res.send('hello')
})</p>

<p>app.listen('4000')
```</p>

<p>打開瀏覽器訪問 <a href="http://localhost:4000">http://localhost:4000</a> 應該可以看到「hello」的文字，從 console 應該也能看到有關 cookies 的資訊（有可能只是一個空的物件）。</p>

<p>再來就是把 mongoose 給 requrie 進來，然後讓它跟 MongoDB 嘗試建立連線，連線的 URL 協議一定要用 <code>mongodb://</code> 這個 prefix：</p>

<p><code>js
var mongoose = require('mongoose')
mongoose.connect('mongodb://localhost/test')
</code></p>

<h2>mongoose 的兩個概念：Schema 與 Model</h2>

<p>MongoDB 是以 documents 為基礎，在 SQL 資料庫稱為 table 的東西，在 NoSQL 裡稱為 collection。當然，這又是一種名詞定義上的把戲，實質上大同小異。</p>

<h3>Schema</h3>

<p>mongoose 的 Schema 概念就是用 schema-based 的方式，定義一個 collection 的組成結構，用程式碼描述會這樣子寫：</p>

<p>``` js
var Schema = mongoose.Schema
var UserSchema = new Schema(
  {</p>

<pre><code>name:      { type: String },
login:     { type: String, unique: true },
email:     { type: String, unique: true },
create_at: { type: Date, default: Date.now },
update_at: { type: Date, default: Date.now }
</code></pre>

<p>  }
)
```</p>

<p>因為 MongoDB 是 schema-less 相當有彈性，所以如果上面這個 schema 某些「欄位」沒有賦值，那麼在 MongoDB 裡就不會有那個「欄位」。說「欄位」是 SQL 的思維，可是我覺得這樣講會比較好理解。</p>

<h3>Model</h3>

<p>而 mongoose 的 Model 概念，則是對一個 collection 結構定義與操作方法的集合，也就是用 Schema 定義了一個 collection 的結構，加上其他對這個 collection 的驗證設定、操作方法等等，便構成了一個 Model。</p>

<p>結合剛剛的 schema 範例，可以再加上一些驗證跟操作的方法：</p>

<p>``` js
UserSchema.pre('save', function(next) {
  // do something...
})</p>

<p>UserSchema.statics = {</p>

<p>  getUserByLogin: function(login, callback) {</p>

<pre><code>this.findOne({ login: login })
  .exec(callback)
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>最後將這個 Schema 定義到一個叫做 User 的 model：</p>

<pre><code>mongoose.model('User', UserSchema)
</code></pre>

<p>當要使用這個 model 只要用 <code>mongoose.model()</code> 將 model 讀出來，便可以對他進行操作了：</p>

<p>``` js
var User = mongoose.model('User')</p>

<p>User.getUserByLogin(login, function(err, user) {
  // here we have a user...
})
```</p>

<h2>為什麼 Schema-less 的資料庫需要 Schema-based？</h2>

<p>不過這就很奇怪了，NoSQL 的 MongoDB 本身就是 schema-less 的資料庫，結果用 mongoose 還要去刻意模擬成 schema-based，這樣的思路是什麼？</p>

<p>其實這是對 NoSQL 的 schema-less 的誤解，schema-less 並不代表 no-schema。在應用當中還是需要一個 schema 來代表 model，而 schema-less 只是代表一種彈性的模式。</p>

<p>否則的話，會需要在很多地方寫髒亂的判斷條件，像是這樣的東西：</p>

<p><code>js
if (cat.name) {
  console.log(cat.name)  // I got a name
}
</code></p>
]]></content>
  </entry>
  
</feed>
