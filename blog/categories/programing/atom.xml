<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programing | @ChingHanHo]]></title>
  <link href="http://blog.chh.tw/blog/categories/programing/atom.xml" rel="self"/>
  <link href="http://blog.chh.tw/"/>
  <updated>2017-01-20T21:02:50+08:00</updated>
  <id>http://blog.chh.tw/</id>
  <author>
    <name><![CDATA[Ching-Han Ho]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CSS Font (2) - 像素]]></title>
    <link href="http://blog.chh.tw/posts/css-font-pixel/"/>
    <updated>2017-01-14T22:49:00+08:00</updated>
    <id>http://blog.chh.tw/posts/css-font-pixel</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/QYgIGri4TjlqD74S4v_H39wBvIzcSIEr8wtKJAImXvSc-ZQO8B5WGE5qvYD3_k3PdinLcUXJ7UHZBLGtZJtAP880O5B9q-WcU_VXJPzVWAxgl3TsT27kXFIOYuPhXQ8koXbDjeQDmFOQ4btB2nw_cWIWaczmLL70eExzVdO_1_Wo7E6jXGdHlkYC8m2al-azmM_8vIY5zWKlrdT2ldDaAofCIV0wVOYZN3QwaRZ1vQyRLHa3Wtp1aP1pj2mIHhTpZBWtXcXOg6VFXS_ImBMKhzEFUtOHYkxKJ89p2aiYSq47XnLCDbBo-4ZdEHWqDvXBkWJcHXFalGwRm_HjhyravjJvcdiudp1NJdkQmYO8Yd06QNs7FY8DzSImi3sq-oJIuO4eHsWM8zOASEy0IgV6VubRVUq4VcOCjxd7DOxRzE6iEk2waFr7cI4IRiShvGQ2mkDjYRcf2bqk-aNlpSP1f3pMnK9B1pYSwz-_AgfIq4ZCkYSkKAxbxOF0q-HWb-QcDv_qnyU7S6bFnwjHXsAV8A1d41y9o5HCGIwJyejBdtbn4WFf_7o5gWJesDFU2Eg8sJoaFknTgvUMrbtoApsRlR8zNxayvAZZhILYPS_qXt1xfrI1SZYmeFPNgRbL818lTrQVd0lCf6a1UHrgtdZ2sndlRDRRi4nb-xlHiJYQHbM=w1276-h718-no" alt="" /></p>

<p>（圖片取自 <a href="https://acko.net/files/fullfrontal/fullfrontal/webglmath/online.html">unconed</a> 網站，版權為原網站所有。）</p>

<p>瞭解電腦字型如何被創造，能夠進一步理解文字如何在螢幕上顯示。本系列文章目的在於研究電腦字型在螢幕上顯示的原理，以便理解 CSS 有關字型的各項屬性背後的設計目的，以及要解決的問題。本文適合對象為從事網頁設計的專業人員，不論是網頁設計師、前端工程師，或是全端工程師。</p>

<!-- more -->


<h2>Pixel</h2>

<p>現代螢幕最小的基本單位為像素（pixel），由非常非常多的「小燈泡」組成。一個像素是由紅、綠、藍三個顏色的「小燈泡」組成，他們透過控制開關、亮度，組成不同變化的加法混色，能夠產生非常多種顏色。為了簡化概念，可以將像素理解成一個個小格子，整齊排列構成一個巨大的矩形網格。電腦在繪圖時，是按照網格座標逐一設定每個格子（cell）顏色屬性的 <a href="https://en.wikipedia.org/wiki/RGB_color_model">RGB 值</a>來呈現圖案。有個說法，像素的英文 pixel 的是 picture + cell 組成的詞彙。</p>

<p>Full HD 的螢幕解析度是 1920x1080，表示螢幕橫向 X 軸有 1920 個像素單位，縱向 Y 軸有 1080 個像素單位，總共超過 200 萬個像素單位，這種螢幕實際所擁有的像素數量通常稱為裝置像素（device pixel）。</p>

<p>有些藝術家、工程師用人工的方式在網格上一格一格地點上顏色來製作圖案，這種圖案風格稱為 pixel art。使用像素方格將文字筆劃一點一點點出來的字型，稱為<a href="https://en.wikipedia.org/wiki/Computer_font#Bitmap_fonts">點陣字型</a>（bitmap font）。以前螢幕解析度不高，要在有限的像素內顯示可判斷的文字筆畫，需要使用點陣字型。現在使用最多的場合是大眾運輸上的跑馬燈，或是某些車票、收據仍可以看到點陣字型的使用。</p>

<p><img src="https://lh3.googleusercontent.com/4EZC27DSZk60uyIXHkeLNCaCfp6gDi5UzHX6EVZmAbOpDuBWonrSRePE4cgxeslOSH4dzN6a3G8VzCwCEECWxE2finNMJRZtRxFvjk14gxhuBq4518uAd91c-CeI7uXpoV_sIYR7gML4aYNrqzAgepVfSJYHzgle0XQXxU_qsDOWHE_4swdo2ega1XiRaSJcBseZq5zSIxduP5evzrq4sbs6zfgmIY7PkwQdsEsi8xp85WR3_N9n8u25glDHThBRMAdGLyMGpR2FYFkmldkIWT0YmuZ2jnK_d_NqGbdFjL1vzvwA5WAyChxapxpsWAHYu5ie4lvjsQOFgWJKHfYdVGE3fJXZpvmoEw5_uroTV2bDtsswRMB13sED_TI_oHAzD03IFHWvqZfVRi-ZArFwrbxKGpH3maY7liAV24zmXq519SI3NPT9FLFMn4RHprv3YoEJMK-09QwZK_Nn3-x_jZIId0zwnDT8LF4kcXr6HYH2IJCrJ7p5BplXpba7i-BK0ou4GJhY59UMbGScAShHSR1Ku7JngJDnAkPhZmkpNWJEoNHgBpBR63G2m6iInAyM5pPmSxHfe7UlYFuP9zUI4j13Uy2nk7qT78X8sOKYuA6miHvn9DJeK7a7KjCYJBYrqibTAveIFNG9QSdWS2PjB-I1_6Jik4x7jEAODuEyKs0=s1600" alt="點陣字形" /></p>

<p>若要滿足動輒超過一、兩百萬像素的現代螢幕，便不可能一點一點地點出文字的筆劃，需要用數學方程式來表達向量的線條、幾何圖形，例如 <a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham 演算法</a>繪製線條、<a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier 曲線算法</a>繪製曲線、<a href="https://en.wikipedia.org/wiki/Scanline_rendering">Scanline 填充算法</a>填滿實心的圖形。</p>

<p>透過記錄文字線條變化的節點座標（x,y）來繪製筆劃輪廓的字型，叫做<a href="https://en.wikipedia.org/wiki/Computer_font#Outline_fonts">輪廓字型</a>（outline font）。輪廓字型使用許多直線與曲線組成文字筆劃的輪廓形狀，再以填充演算法填滿內部空間，繪製成文字，這個過程稱為算圖（render）。</p>

<p><img src="https://lh3.googleusercontent.com/WHzAidFm9liuCdl8PO8dyPUWFYAOxwI2M4CNCh0xQoBCSo_tCdqQ3hX96y0qYyn4oLtZnjdIzlx4z_b6HBrgRII9UF_THi_EBNzDwsCOEHDqQzdzBb-EiohTtWNdvpNQWQPNI6z4FAesQROqPDil-i2-uLup3kagfCa-0qYAs5qrVYxG_Yb1ojAsxWJuuBQg2-h99jEHmypIBLc9J2MfUNuJReGsUl5tRKgJqjhVjJQatGfH01yjrTPNvSbjR3hnYZPm4CVSa1UT9byv9hGpH-nNl9EjvynQvArA0tzHXwDnV9BMNEaW7Q3A8iXwu03HbecCglRmc6grTr3EHoewmzRes15Hj79qxgCQXCEb3A-RHqZa71MQ9bykR1g4ZXmjTSwWRbdpDBRfHMNHYI7lS2JyaMonlPNWJxnMGg9ytfi2_kigx7EfCL5otj4YQQXnIPFKGt_6GoBBX0rjLYho5z3NkJk0mGrdRApua21Te0WPvR1RLuk7jm0v-0GUYMBX1rvoLvGmHemOuQPLISHFndtFTgPk4RYCWVTv1IvfqQI9HWpMsvFtgM_3QWJr56KcXwvCjMVhMvJ_waQZHQvj8D8sOSHGCPlSmAnwHeAWuVSwG2Bl-LshaZ4JgzboHdC7xR3-l5RL3h6bO4DgHCghpRf0UlsVi36JBtCADzzX6X4=w706-h628-no" alt="輪廓字" /></p>

<p>目前算圖並沒有一個統一的規範標準，各個引擎的實作方式皆有些微差異，因此在不同的瀏覽器（Chrome、Firefox）、作業系統（macOS、Windows）上相同一套字型的同一個字母，都會看起來不太一樣。</p>

<p><img src="https://lh3.googleusercontent.com/9Hy5Ta3RBWYdhc-IS8FaUwRFCVx795D_9jtScJhIaWsQJ2VLMU0HVf9S2ptpwuAyphS7x1sVuN9f3NPONlxsNUNU9DMQCWldsjKr12J-kLVV_4U0bfNiikauuq5RXB6Ytcf-HMZaN57hLk_o8HRXDubsg1jDvTISCCteow8C374bdfOxlmhbzHXMeTROMX9iZQWGWSvXT3aq_UXjHBBKZw_4uzn7utR3CIIp3MF9uy83JJscK-5-lhZiaXmhCJPYHJ3ZnhuGNJ2E_4FBdE1GkXJE2yr--GFiqW3vAR5BzQANp1h87f9iHIq_f4dWpC-IuvXKvzh5txrRBlVhGd06hXHFXjMDVy5OQQj-7Fq_FBTuWa-F5bnyq4pKdzsYh6NP1W3SENKqdn2-5RvKWJSUhg1m9M2pt93AD2PEejuMLzu4GkN1ivfCRoxOStabAi3fOlYv0z7DmlTaMrWBS1LgzpwT9M19gpTzXPRMImmXWJK9Mky66_Tezbd0cm0JXjjoEEfgwFtqCq6y5R4tG87Qi4fAcbcMOYFr_OOVbnxd9rcQ1cuXcB4sYgTh2jYTpBiPp4qGQpsC0r8rkrDJXJkL6t5g7DnroHftjSQWtMmofxT9Jld9unNWGWk3CyVqILN9IhbJZvb2HSB5otvOoI7ZXMCc1v-uR8Lj_0II1BtgHK4=w450-h74-no" alt="相同頁面不同瀏覽器 render 的結果不同" /></p>

<p>不過螢幕像是個巨大的矩形網格，無法直接顯示向量的圖形，顯示過程需要經過點陣化（rasterization），由電腦程式自動設定每個格子的顏色屬性，將向量線條轉映到一格一格的像素上。</p>

<h2>px 不是 Pixel</h2>

<p>裝置像素的單位以 px 表示，但是 CSS 所定義的 px 並不與裝置像素 1:1 直接對應，至少不是想像中那麼單純的 1px 等於 1 個裝置像素單位，儘管他們都會使用相同的表示方式：1px、320px、1920px。可是兩者定義上卻有些微差異。</p>

<p>須知 CSS 支援的長度單位相當多，有字型排版歷史流傳下來的 pt 以及 pc（pica），也可以使用日常生活可能每天用到的公分（cm）、英吋（in），還有個最特別的單位是 px。對於已經熟悉 CSS 的工程師、設計師大概沒人不知道什麼是 px。px 不像其他單位有實際的物理長度可以相互轉換：</p>

<pre><code>1in = 2.54cm = 25.4mm = 72pt = 6pc
</code></pre>

<p>因為他們是由實際的物理長度組成的絕對單位，物理長度不論在哪都是相同的，基本上每個人伸兩根手指大概都可以比出一公分大概有多長，但是螢幕因為解析度不同，每英吋像素密度（pixels per inch，PPI）都不一樣，例如 iPhone 5s 的像素密度是 iPhone 3G 的兩倍，兩者裝置像素 1px 不會是相同的物理長度。</p>

<p>W3 早在 CSS Level 1 就提出了<a href="https://www.w3.org/TR/css-values/#reference-pixel">參考像素（reference pixel）</a>的概念，定義了 CSS 的 px 單位是參考像素而不是裝置像素。參考像素 1px 等於 1/96 英吋（大約 0.26mm）。與其他絕對單位的轉換公式可以寫成：</p>

<pre><code>1in = 96px = 72pt = 25.4mm
</code></pre>

<p>當設定字級 12pt，電腦需要將 pt 單位轉換為參考像素 px，才能知道螢幕需要用多少像素來顯示文字。依照前述的公式做簡單的單位換算：</p>

<pre><code>12 / 72 * 96 = 16
</code></pre>

<p>計算結果是 12pt 的文字在網頁上顯示的合理邊長為 16px；當 CSS <code>font-size</code> 設定 16px 即表示設定 EM square 邊長的對應像素為 16px，換句話說，<code>font-size</code> 的大小等於 EM square 的大小。然而這只是字型的 EM square 的高度，並非字形本身的高度，要計算字形本身輪廓的像素寬高則需要從 EM square 的座標系統換算。</p>

<h2>字形座標轉換 Pixel</h2>

<p>技術上 EM square 是個二維空間的座標系統，FUnit 是等分座標系統的單位，沒有實際的物理長度，只用來表示相對的距離。為了能在螢幕上顯示字型文字，需要將相對的輪廓座標（x,y）等比例縮放到具體的像素座標上。</p>

<p>輪廓字型以 Roboto Black 為例，這個字型 EM square 邊長為 2048 FUnit，大寫 I 用了四個座標點，座標點之間皆為直線線條連接：</p>

<pre><code>x=474 y=0
x=137 y=0
x=137 y=1456
x=474 y=1456
</code></pre>

<p><img src="https://lh3.googleusercontent.com/wwZ5ylRJC6VM5MVFhB7D4he8hF2x3-gjzHQmr_Lj01RJ0MonUrOe3Mzhgd4EgItDuynUZL9FhWjixWmHdfccX_MryTOFAFdy0A5E6s669-lMpzDTjqow_-P1PNVceVxeWud69JzRIh4g8gwVWVljvEZCCKwP9SJJifBjUxQFdGCaghsgvYhbomk2VXM2qdAu6KK-jMwZW_tQAuTq6SIaY294XZFBzMdvbkoFo4MGU89jTDJ0-elKs-WZQUlhBtjrQjbeVdlZA7e57SltdJNw2fCy94mO0GWhR4l_J8pe842wPBeI-qBnjJIimAGmTDwUJTKrhjhRUdyWt4BiMJ0sCW4MCXMh2-TcZXXB8rETfJpgWputpDI1S-QhvWNg56jxeOFee-MucQxPuD0bbicwBh8nQuIjRld4UEto2RyGgODq9T70Wgy_9MBRd30GzGMevFR_OZhFwG_IBhvzryxFS0FWloU90W6q8ispbs2LRnpU8058_JymUlRwmbfrIMJW-bplo_n23hIPV4N06oOFkB0_8zae2S4ecMQwGQO5CPhOoEun7_-TrmGdQioOFjpaX7k3gDlzpHENyrz_D5XcQCqkDTizEJStdsKxNUceH8--eEDAoLlbgIIpM57V4007j6hiVQnhGB8_7kWjni6XXEGX99bgv02Y6gAppvUxz7Q=w500-h382-no" alt="roboto-black" /></p>

<p>網頁上如果設定 12pt 已經知道合理邊長為 16px，做個簡單的等比例縮放計算：</p>

<pre><code>(round(x/2048*16), round(y/2048*16))
</code></pre>

<p>最後的像素座標分別為：</p>

<pre><code>(3.7, 0)
(1.07, 0)
(1.07, 11.38)
(3.7, 11.38)
</code></pre>

<p>由此得知這個字形最後在螢幕像素上會是個寬高 2.63x11.38 的矩形。也可另外使用以下公式計算字形會用到的像素寬度跟高度：</p>

<pre><code>X/Y軸使用的FUnit * ((字級大小pt * PPI / 72 * 字型UPM尺寸))
</code></pre>

<p>試算結果：</p>

<pre><code>337 * ((12 * 96) / (72 * 2048)) = 2.63
1456 * ((12 * 96) / (72 * 2048)) = 11.38
</code></pre>

<p>因此可以計算出 Roboto Black 的大寫 I 寬度使用 2.63 個像素，以及高度使用了 11.38 個像素。不過像素是螢幕上的最小單位，基本上是一個一個的整數，無法只顯示半個像素，為了實現這個目的，需要用到反鋸齒與子像素的技術。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS Font (1) - 基本概念]]></title>
    <link href="http://blog.chh.tw/posts/css-font-em-square/"/>
    <updated>2016-12-17T12:59:00+08:00</updated>
    <id>http://blog.chh.tw/posts/css-font-em-square</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/_vIG5mKzyW0lcp8INazZP3wb3d5tdN2fkEBLHzy-DJMsqzoski-1WcsUA4T-JlFYHgWqRce8Zk0ErcVQn2gR7UvaeN-MJAlFlWGh2n_sJC71dQZ_bFmXpLsOc1an7dH9u6vt44ES-Ljs6x-RbXMz_ObYyZ9vRgH18eTfVFipTJxjxPPgeynvgkWIzz6W2J6aPE6irkS0I8QXUcNMM0WNGW-b5utOd5AQl0qrp0Ti7YHiHArmd-WciTrzdi-M3AngJVw2EPt7WoBPl4DQE-NbIZHEXjp5CEoq-D6fyeefjCK6eWn-wRyqfAbVHID_R_xtajVEUz2ApIi4RxF-urECPudmJFmvy6mJTH1o5exK5-EY9sofFXxiApntimCfoRc1V8J7iyhIAO3er_JrSOAPe76DsQeC2LcHVUIE9zpos4SMgOXj4RsMjsd0U-jOJHeVmOFiMJJKV-BkHGEdQp9EV5L5nFJOoxX-Hd40mgPRwLJa1GflN055qBd0Fh44MxPTkncgBi8mhqaUNpJobO6qWRbXCga1gDRoJDUQL-Df9i5-agXegiwDpzMdW4tmu3QjFQ-e-DPLoeFmT4pYrHsYiBGCuS8pTD0rx5fG6HVaMFMy7W4dKQ=w483-h346-no" alt="2048" /></p>

<p>（圖片取自「<a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM01/Chap1.html">Digitizing Letterform Designs</a>」，版權為原網站所有。）</p>

<p>瞭解電腦字型如何被創造，能夠進一步理解文字如何在螢幕上顯示。本系列文章目的在於研究電腦字型在螢幕上顯示的原理，以便理解 CSS 有關字型的各項屬性背後的設計目的，以及要解決的問題。本文適合對象為從事網頁設計的專業人員，不論是網頁設計師、前端工程師，或是全端工程師。</p>

<!-- more -->


<h2>EM square</h2>

<p>傳統金屬活版印刷把每個字母刻在一個金屬方塊上，方塊不一定是正方形，寬度可能不同但是高度相同，這樣才能整齊地排列字母。由於英文中「M」這個字母比例接近正方形幾乎是最大的一個，因此金屬塊的寬度被稱為「em（M）」。</p>

<p>在數位時代一個字母的空間容器從實體金屬塊轉移到虛擬的電腦程式上，電腦程式會建構一個虛構的空間容器被稱為 <a href="http://designwithfontforge.com/zh-CN/The_EM_Square.html">EM square</a>、EM size 或 UPM（Unit per EM），術語源自活版印刷技術的歷史，而數位字型也將以此作為容器基礎。</p>

<p>字體（typeface）指的是文字的外觀風格，常見的字體例如標楷體、新細明體、微軟正黑體、蘋方體、Times New Roman、Helvetica 等，基於相似概念組成的集合便稱為字體家族（font family），也是 CSS 的 <code>font-family</code> 所設定的名稱。</p>

<p>字形（glyph）指的是字元的形狀，由程式演算法或是文字工程師、設計師手動調整的形狀本身。一個字型的所有字形都有相同的 EM square 尺寸，差別在於字形的大小不同。</p>

<p><img src="https://lh3.googleusercontent.com/g1lcXEFfL9nixF0Y2Y_iGmWdB_0IDR7x8lc1Qyvsmm9HaADlF3NuwPsYRAgYZGIDfiTkE70Bzplb8wTlXMlWomr5oW3pYh82SeoK4Up0JDWVTTfBFb1uGlhuqeOSgxVxY3EQnZv7z70PqQedGmiKk3bslIllLWK_qkm0UAkz_-bH8Tu5UofMGV79RDcMCLsPcTHmz4aIv8kgwSV1v9QOsBnwzHA5VxGkUhYaI43KF7wrI8671AiRWqdoVC50fEnAilnAZfdEOuJYemEPrK08WILJhE4TsU9vT-HyyNjVbyofFkZjAuoTz38Ar8Ui-fhF_2oyqIQ_eT8IyzcAqWJdID_LQpavb4l7t_oFXvtcUMUCmBgbr0vwwBghubTM3hCP1X-L4uDYLA3ZRcZRxUilyfvx77eY5Ql7ShBQbV_WODZxsEGlTvXJVKG_R63uS01mWg0JEXEmD-hWc75yDofawRB_9wXU9iAbqR6PrFlyUUXvrRBGqDj5tqlnz1IXaOO_yviAqlWaWLjOTEP5sayRQmzlM2XsS0IOalze94YySZN31VJ34Yisf5kBjhdDQVUz5XgENmTyBCjK_CKihb-BiuT1UceXbU_sYPDNrcvMKnV1BJOIEFd2b6pWUQZ0ZtKaFc5_RyiBRZH70dyaCw0VL4_Dm8l9hwMIsaXvK89Yxj0=s755-no" alt="EM square" /></p>

<p>在技術上 EM square 可以看作是個有限的二維空間座標系統（x,y），寬高可能是 2048x2048（單位 FUnit），<a href="https://www.microsoft.com/typography/otspec/head.htm">OpenType 官方規格建議大小是 16 到 16384 之間</a>，但如果主流軟體無法支援便失去了意義，例如 <a href="http://typedrawers.com/discussion/comment/863/#Comment_863">InDesign、Illustrator 特定版本無法正確處理 EM square 超過 5000 的字型</a>，所以 EM square 的尺寸需要取決於軟體的相容性。目前比較常見的尺寸通常是 1000 或是 2048，例如 <a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM01/Chap1.html#master">Apple 主要字型都是以 2048 FUnit 去設計</a>的。</p>

<p>字形基本上都會設計在 EM square 的範圍內，但也能超出這個範圍，視字型製造商的偏好及決定。</p>

<p><img src="https://lh3.googleusercontent.com/87tTVmRKfgB9GM7NZWF6ip9nHW-NKYGy8gNU9f8K3aMZXCkg0f16JGgT4-_0tht9i5WpLWOHJYi3NKflZiRjHg5ve1V9lKnUVTGiubZwDXkMuizGc2jP-hozP4zLsLPQlVM_Jmfs65TrS_exYL-BmWRc_h2g9YwxAZkB08zoX3CmEiTfVsehGl31MPuB0C3JtpObW19usVSG98AMDSrYQIt_SxYu58sBQEpfTKpJprFjND5IP7um5IKWuqJixDHjr3ZwF4k4y9b3PiCr3KV7OrpzF51Gl7_HvNfZPzCKt-8vCEgIRODN26N5NjEv6Gq7wuKDDItU30Ukj1RUOibGYlv6grb39g2EkiPwQsnYx9R0FEBvOHP_LrZMfzPH8-Yhqka99lIAbQT2-29593zDY3CqKTB3pFADrqM9zJSUNz3zTU_qeBZppdVZ3IflBaDdD1uKDBlVSe9tu6HQqoxFgNpXBmQmuuX6uI7s5CNpWDtocaon9VfyhWPxzRsKYlABBP5L8Ag3TC7GOwFvKGjwK1lse5WIuK1t8HgC9MniNHW1iIenF0H33kvPruTispc31EV8lpz3w4uQNJFmFzMWVB-KmKXqOCdlTu5oJ1iqxVhsNB8bV8X1mVDzKu3w00-oQvVexxWi5FUd_ng1hs7oDY2VnOXW6nSyeCmrxOq0YPA=s799-no" alt="Character extending outside of the em square." /></p>

<p>當指定 CSS <code>font-size</code> 16px 瀏覽器便會將字型 EM square 的大小映射到螢幕 16px 的大小上，可以參考我的另一篇文章「<a href="http://blog.chh.tw/posts/css-font-pixel/">CSS Font (2) - 像素</a>」。</p>

<h2>字形解構</h2>

<p>觀察英文字母的書法規則，可以歸納出一些模式，例如每個字母基本上都坐落在同一條水平線上，這條水平線稱為基準線（baseline），相對於其他字型或字形決定如何對齊，不過這是針對英文（正確來說是拉丁文）字型設計，中文字型由於都是方形等寬等高的，因此不需要基準線的設計。</p>

<p>此外，基線到字形最高的頂部稱為升部（Ascent）；基線到字形最底的底部稱為降部（Descent）。在數位字型中，這項規格制定在 OpenType、TrueType 的 <a href="https://www.microsoft.com/typography/otspec/os2.htm">OS/2 表格</a>中 <code>sTypoAscender</code> 及 <code>sTypoDescender</code> 的值，或是 <a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6hhea.html">HHEA 表格</a>中的 <code>Ascent</code> 及 <code>Descent</code>。OS/2 是給 Windows 的規格、HHEA 則是 Apple 的規格。</p>

<p><img src="https://lh3.googleusercontent.com/qC070S-SC4Z330u2-mHASXfdcuMaSWZeJLLkMrdDcjZ-k5U5mPDwHJJPOSpT_mCwVtofFUjevRD3BI9mqIXEfJp39UFkk9cCRD-KcciLuOGQalz2xBk8i3skrqOCgv92jiJsqAnK99jXGV_Qjr0vosSo2_tgZmZXdMrGSRemvVDsw9Gn2PYg8VNhEjxnZNAZkoeCUPe9hPg7ecTpWWpJKhWgUY-UnQTRtV3KIGKEIufRnhjwMQrE4rkO2l3v6l5BX3_Gultxc-hNkJ9-0ScKhGMz5gyPHKHBLiykv0MATtp04_292JxcO8079Qoy65mMWIE8XPjvYdcfJR5GhxiKk2seNof0f4gAb-jjhDl3u7SvA8XI8-VAHm2wPS2qgMCP_w8jxM__VhbJDnOcBqBLBpbNz3P_o3AjXPUy6S5fVGbbT7DSfhPDSn2RAEUIi0K68ZnfaeX0VRWqPY3vQ_jq_wDsasqZYw2NedOFpR5VVvgK3MSfKN40jw1qn7_IaXnClwSgZzNZJqZ7UwYthjUO-QxZlTGQyCILBnnye3b5aEAJmIlDXD08GWMj9Hu778uap1AJcX1mseJb4L_fwlv3NSQzutLmJMeC2zFrCXtvO3Om970ucDOllxt3kP2-n08cy9igomlsEgUa1G46u3HyVvITc51D22ZbbkpfH0gLfMw=w914-h738-no" alt="" /></p>

<h2>行高</h2>

<p>印刷排版中的行高英文是 leading，指的是兩行文字中間的距離或空白，但是 CSS 的行高（line height）略有不同的定義，因為它不是只是單純地加在行與行的中間，而是先計算出 leading：</p>

<blockquote><p>leading = <code>line-height</code> - (ascent + descent)</p></blockquote>

<p>然後 CSS 將其中一半的 leading 加到文字的上方，一半加到下方。舉例來說，指定某區塊字級大小 16px，行高設定 24px，則 (24 - 16) = 4，CSS 會在 16px 的文字上面及下面同時加上 4px 的空白，最後整體文字區塊（inline box）才會得到 24px 的高度。</p>

<p>W3 規定 CSS <code>line-height</code> <a href="https://www.w3.org/TR/2011/PR-CSS2-20110412/visudet.html#propdef-line-height">預設的值是 normal</a>，並且建議這個值可以介於 1.0 ~ 1.2 之間。為了測試實際 line-height 到底是多少，我準備了一個測試網頁，在 Chrome 跟 Firefox 兩種不同的 render engine 測試不同英文字跟中文字體，得到以下 4 個測試結果：</p>

<ul>
<li>不同瀏覽器 normal 不同；</li>
<li>同個瀏覽器 <code>font-size</code> 不同 normal 實際值也不同；</li>
<li>同個瀏覽器 <code>font-size</code> 相同 font-family 不同 normal 實際值也不同；</li>
<li>雖然 W3 建議 normal 應該介於 1.0 ~ 1.2 但實際上隨著 <code>font-size</code> 與 <code>font-family</code> 變化，可能會大於 1.2；</li>
</ul>


<p><img src="https://lh3.googleusercontent.com/2YoOk7Z7nao8okS7x8r351ZcSxuz9OHWziJEkoYIIEfsZlm6pcN-2vEGGL_Meh001IBPfSdw_JApeQ2ONLzlIdjs-1jkWS9Nz1REdtiY6pbY4SUKZFYEcPTDLk5WuZFoo_UiGfgSVBUJ6F-mm549PqzgxBp279iQM0B5GrrAA62MKUAfHxVJmRLQohvPVh2PKA9I5tvHdQUO0Y0N1J_Up3CCSlPaSB9h4Zvoj4wZ6M51GeJi39OeqZUu_XL-YAPOmQSTXvDAgBwaiMlAXUevxBCkoARGDOKGXB8Z3mW_OyPHwv4Af37-MYgzO4SyMQWoHoocYLBxtPIV4QzRRQTUaU9lroOE2q5blXCwQHSTVWY5tIej_tjB_P4Gy6AV4RSyKJDnUXom5s5vCMGCma2CU851laqZV4nYiLRVQXv61ngtRDBLn5xujjTLM66AG4nwfr7yeCXrbCLpO8aA0__33F5lHlZITIaq5zvbDYfe2wME_j3AWmunQ2zir6pBJ9W8MTDttq0LG4d6MVW9P4_joHIcvO-670lGG6rLMiY14AJtTqrx6aminh9E4u_e2Nve6ayuPHipD5GxFtbRYHEJLFk81kgpNtdtQcGAuT79HxNn0TaHKg=w1071-h799-no" alt="line-height-compare" /></p>

<p>不同瀏覽器預設 <code>line-height</code> 不同，要解決這個問題也容易，只要在 <code>&lt;html&gt;</code>、<code>&lt;body&gt;</code> 指定固定的值即可，例如 <a href="https://necolas.github.io/normalize.css/">normalize.css</a> 指定了 <code>line-height</code> 為 1.15，<a href="http://meyerweb.com/eric/tools/css/reset/">reset.css</a> 設定 <code>line-height</code> 為 1。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SCSS 物件導向模組設計 (1)]]></title>
    <link href="http://blog.chh.tw/posts/scss-object-oriented/"/>
    <updated>2016-10-02T19:47:00+08:00</updated>
    <id>http://blog.chh.tw/posts/scss-object-oriented</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/mZCl_NgujdrKc-XhTqKsXA30gUb7dGQaQhe4Jjx8Blj4_97XWHoy5Zbfq6bk2GCu59jt0Gdu1Li8wCI3iCr9ejKu_wFJxzI4u6IrFl--RQ3KER-J0s4WXZ7f5VuQkH9Kc1TijUI6tHbGMdCt-r_fYO9wUI9ImbRlIhBTW4dgkg2YRDwIFbJjeMGWgQHBtjUb1dmsmjmKtcqWVPH5yfdnXxItyvLUCuA2zuN1dW90gljU6fdj5p1ivtoNQERUrJpXUhF0F_sDQcYsc2m9YzzOKvVnmvYDo0tUtmw1YzUts1PwrybI-G9c-7gKrc12Z_8PZl9dmF4GqOmi4c8ODPFFTxnZZGW5OYTGYah3LtiEQR8OzDY5HuOEKm2LUGPOLdBHRZVT-Xs6Ljy1cx6DLIAVPb1Q1SukfmDigXDyaLimn9-oEazRlugDF9Q2qStJaRzrsi2Ht6tnFZ8LK1XsTjgFpMh3mRnGQCKBewIjd7FiVnYGtT0f3XMhkSjv24UYW3gJAZuPLBjl4P8YQBW20ZLWQi33oCDxQKLr6MOLp-cx7YjOGSqfoYkAvcy3F08TyA2XAhV2PL_4g5gAqnETmUZOPmep9kHwy1gFL1eYJhTdLAcH982D-w=w1101-h755-no" alt="" /></p>

<p>三年前曾經寫過「<a href="http://blog.chh.tw/posts/oocss-smacss-and-css-guidelines/">劣以為的 OOCSS 和 SMACSS 以及其他 CSS 規範</a>」探討 OOCSS 模組化的方法論，時至今日對於模組化設計又有新的認識跟理解，大原則跟三年前的方法沒有出入，只是多做解釋跟補充。</p>

<p>OOCSS 物件導向是解釋設計原則，但是不限於語法的設計。</p>

<p>如果這個議題有興趣，歡迎繼續往下閱讀，如果有任何想法也歡迎留言與我討論！</p>

<!-- more -->


<p>這篇文章會解釋的內容，包括四個設計原則：</p>

<ul>
<li><a href="#srp">單一責任原則</a></li>
<li><a href="#lkp">極少化原則</a></li>
<li><a href="#isp">介面設計原則</a></li>
<li><a href="#ocp">開放封閉原則</a></li>
</ul>


<p>SCSS 模組化設計模式：</p>

<ul>
<li><a href="#cp">元件模式</a></li>
<li><a href="#sp">語義化模式</a></li>
</ul>


<hr />

<p><a name="srp"></a></p>

<h2>單一責任原則</h2>

<p>一個 class 只負責一件事情。這個原則不是指 <a href="https://github.com/marmelab/universal.css">universal.css</a> 這種設計方式，事實上這個專案是個反諷。單一責任原則是指職責獨立、目的明確的 class。</p>

<p>``` scss
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}</p>

<p>.clearfix:after {
  clear: both;
}
```</p>

<p><a name="lkp"></a></p>

<h2>極少化原則</h2>

<p>對於層級的依賴應該盡可能減少。</p>

<p>多半的人剛開始寫 SCSS 都為它的巢狀語法感到著迷：</p>

<p>``` scss
.page {
  .content {</p>

<pre><code>.header {
  .inner {
    .group-list {
      .group-item {
        a {
          ...
        }
      }
    }
  }
}
</code></pre>

<p>  }
}
```</p>

<p>這個寫法有改善的空間，因為：</p>

<ul>
<li>不容易閱讀：當層級非常多的時候，哪段屬性屬於哪層 class 會看不清楚。</li>
<li>太倚賴 DOM 結構：一旦改變 DOM 層級結構，SCSS 也可能會需要做層級調整，層級越多耦合性越高，意味維護成本越高。</li>
</ul>


<p>改善的方式便是在相同的命名空間下，試著將層級攤平。適當使用巢狀語法的範例：</p>

<p>``` scss
.nav {
  list-style-type: none;
  margin: 0;</p>

<p>  li {</p>

<pre><code>display: inline-block;
</code></pre>

<p>  }</p>

<p>  a {</p>

<pre><code>display: block;
text-decoration: none;
color: blue;
</code></pre>

<p>  }
}
```</p>

<p>即便 <code>&lt;a&gt;</code> 的 DOM 結構是屬於 <code>&lt;li&gt;</code> 的子元素，仍然不影響它們的作用：</p>

<p>``` html</p>

<ul class="nav">
  <li><a href="...">...</a></li>
  <li><a href="...">...</a></li>
  <li><a href="...">...</a></li>
</ul>


<p>```</p>

<p>有時候與 DOM 元素本身有絕對關聯的 class，可以在使用區塊註解加以說明：</p>

<p><code>scss
/* ul */.nav {
  ...
}
</code></p>

<p><a name="isp"></a></p>

<h2>介面設計原則</h2>

<p>針對介面設計，而不是針對實踐方式設計。這個原則可以減少重複的程式碼，增加可維護性。</p>

<p>例如兩個有著相似樣式的區塊，往往會針對區塊實踐它們各別的樣式：</p>

<p>``` scss
.card-default {
  border: 1px solid hsla(0, 0%, 33%, 0.85);
  padding: 15px;
}</p>

<p>.card-primary {
  border: 1px solid hsla(0, 0%, 66%, 1);
  padding: 20px;
}
```</p>

<p>``` html</p>

<div class="card-default">
  ...
</div>




<div class="card-primary">
  ...
</div>


<p>```</p>

<p>應該先設計這個模組的介面（interface），再依照介面實踐它不同的樣式特性：</p>

<p>``` scss
// 先設計介面
.card {
  border: 1px solid transparent;
  padding: 10px;
}</p>

<p>// 再實踐不同的介面樣式
.card-default {
  border-color: hsla(0, 0%, 33%, 0.85);
  padding: 15px;
}</p>

<p>.card-primary {
  border-color: hsla(0, 0%, 66%, 1);
  padding: 20px;
}
```</p>

<p>``` html</p>

<div class="card card-default">
  ...
</div>




<div class="card card-primary">
  ...
</div>


<p>```</p>

<p>一旦先有了介面，後續也才能夠知道該怎麼對此模組進行擴充。</p>

<p><a name="ocp"></a></p>

<h2>開放封閉原則</h2>

<p>對修改封閉、對擴充開放。除非是根本性上地調整模組的樣式，才會需要去改動到介面層級的樣式。這裡引用上一則原則的範例：</p>

<p>``` scss
.card {
  border: 1px solid transparent;
  padding: 10px;
}</p>

<p>.card-default {
  border-color: hsla(0, 0%, 33%, 0.85);
  padding: 15px;
}
```</p>

<p>``` html</p>

<div class="card card-default">
  ...
</div>


<p>```</p>

<p>當某個頁面需要對此介面做特殊調整，可以使用開放封閉原則，對此介面進行擴充，而不會影響到其他頁面樣式：</p>

<p><code>scss
.card-users {
  border-color: hsla(0, 0%, 100%, 1);
}
</code></p>

<p>``` html</p>

<div class="card card-default card-users">
  ...
</div>


<p>```</p>

<hr />

<p><a name="cp"></a></p>

<h2>元件模式</h2>

<p>元件模式的哲學在於 class 本身與語義化無關，應該關注它們是否合理，不要刻意強調 class 名稱要符合語義，而要注重使用的合理性與未來性。例如：子元素區塊使用 <code>.list-item</code> 上層元素使用 <code>.list-group</code> 作為子元素的集合，這與元素本身是否是個序列清單（<code>&lt;ol&gt;</code> ）無關。</p>

<p>在前面瞭解過四大設計原則之後，現在已經可以很輕易地設計出模組。先設計介面（interface），再實踐不同的模組樣式：</p>

<p>``` scss
.card {
  background-color: transparent;
}</p>

<p>.card-default {
  background-color: white;
}</p>

<p>.card-primary {
  background-color: red;
}
```</p>

<p>在 HTML 上的使用方式：</p>

<p>``` html</p>

<div class="card card-default">...</div>


<div class="card card-primary">...</div>


<p>```</p>

<p>元件模式好處在於開發前端版型，只需要專注在刻寫 HTML 上，快速調用各種模組 class 名稱、減少花時間替 class 命名的 context switch 成本。缺點亦即很容易過度膨脹 HTML 體積，例如使用熱門框架 <a href="http://getbootstrap.com/">Bootstrap</a> 的人們應該對此都不陌生：</p>

<p>``` html</p>

<div class="col-lg-9 col-md-9 col-sm-9 col-xs-12 col-lg-offset-3 col-md-offset-3 col-sm-offset-3">
  ...
</div>


<p>```</p>

<p><a name="sp"></a></p>

<h2>語義化模式</h2>

<p>語義化強調元素本身所代表的意義，但並非漫無目的地設計 class；結合四種模組設計原則，加上 SCSS 語法的便利性，可以很容易地設計出容易維護及擴充的模組：</p>

<p>``` scss
card {
  @at-root {</p>

<pre><code>%#{&amp;} {
  background-color: transparent;
}

%#{&amp;}-default {
 background-color: white;
}

%#{&amp;}-primary {
  background-color: red;
}
</code></pre>

<p>  }
}</p>

<p>.content {
  @extend %card;
  @extend %card-default;
}</p>

<p>.sidebar {
  @extend %card;
  @extend %card-primary;
}
```</p>

<p>這會產生出以下的結果：</p>

<p>``` scss
.content,
.sidebar {
  background-color: transparent;
}</p>

<p>.content {
  background-color: white;
}</p>

<p>.sidebar {
  background-color: red;
}
```</p>

<p>因此可以清晰、明確地定義出區塊所代表的意義：</p>

<p>``` html</p>

<div class="sidebar">...</div>


<div class="content">...</div>


<p>```</p>

<p>語義化模式的優點在於減少 HTML 冗長的 class 名稱串聯，透過 SCSS 語法優勢，對不同的區塊套入相同的模組樣式。缺點在於切出每個區塊時沒有那麼容易替其命名，增加了中間「做決定」的思考成本。</p>

<p>兩個模式並非相互衝突，可以在適當的時機交互結合應用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用一個 HTML 樣版引擎的選擇重點]]></title>
    <link href="http://blog.chh.tw/posts/how-to-select-html-template-engines/"/>
    <updated>2016-07-22T15:02:00+08:00</updated>
    <id>http://blog.chh.tw/posts/how-to-select-html-template-engines</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/QgvDvJX1TZztm_lBHTgAD2gEhw89v82uk9DVs1l69GlRVlSQ_fRxQ_WiNk54B-iUbyPB7AoUm2ZoBpHUD3cN99AHB6VTcSVUG24zeEypIKoWgk9cUnbnPMHsvmU5eoBjjQSBKaPBitjKvu82xnqYL5Gm0mMlU8OAzHcmh3_WxZx8EUsqB-roXuFp31zGkW84Z4JY3l01F6mPK6vTss_Xdg707k0y4lo0OX8mUnETc196rK2L5-y1clcgvLB33qvaBAHQq6JOqbuOmcV3_qbJb-NDC714KqTB-R6m15KBcTYk_72s8rUUOTKDGjDpsm-nVIGdwxJAjYICl8Cz7mB_c9pVeRKdx17ennNpyhUrK1JYuWAk4Gk9wPQv3_lt8PuxrvUMZwwkranlg1Ob0MB6XuQSn2MFaEGU1XFbgAOMZ6iPKjxceKupt9bE5aPevLjMk_O_WvKQAAzwg7Ne8BK_tUrmHWbYwvhUUpcwV-sKSsCFrE4Ps31LvgxqMWQ-c_Z0iq7Ou5WFWfc2eDrx_JWptmkTeWDfBmjo9uVuusVuXjy4g1G-GpSUIhU8ZYTBlKZZJA3dFRwevNTOmlC_hsFL8kgcfqbm_SXP=w1101-h493-no" alt="" /></p>

<h3>語法</h3>

<p>首先當然是要喜歡上該樣版引擎的語法，因為使用樣版引擎的主要目的就是為了加速撰寫 HTML 的生產力，給先讓自己喜歡使用它，才有辦法寫得有效率。多數樣版引擎的入口頁會用簡單的範例，快速火力展示它的特點，這是很好的開始。但也因為這是精心設計的著陸頁，目的是攻取心裡的小惡魔，所以在選擇採用這套樣版引擎前也得特別小心。</p>

<h3>擴充性</h3>

<p>一個好的樣版引擎可以讓自己掌控專案的伸縮性，例如註冊新的 helper 跟 block，節省撰寫重複的程式碼，靈活地設計版型架構。</p>

<h3>安全性</h3>

<p>對於經驗不足的開發者來說這很容易鑄成大錯，在沒有意識下的輸出未消毒的內容，都可能會造成使用者傷害，而一個好的樣版引擎應該要預設消毒輸出。如果對自己的經驗很有信心，覺得這是初學者才會犯的錯誤，但也不能夠保證其他同事們不會粗心大意。</p>

<h3>勿矯枉過正</h3>

<p>使用樣版引擎是為了增加團隊在撰寫 HTML 的效率，所以應該以團隊的技術水平作為優先考量，如果團隊的平均技術水平沒有達到而貿然採用也只是增加大家困擾而已。 不要為了使用而使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Zepto + Velocity 無縫取代 jQuery 更輕巧]]></title>
    <link href="http://blog.chh.tw/posts/using-zepto-replace-jquery/"/>
    <updated>2015-10-01T00:26:00+08:00</updated>
    <id>http://blog.chh.tw/posts/using-zepto-replace-jquery</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/fKcLfP4rJK5syiKv-cfmDYlbdC0_dV8sAdyQfYM3DxZW76knVkgxFsMC4sWsBpaN_27emoOHF504CNpmSDn0rnlDG2Eu1vw6RNowi18owUxdnBYaotT3hz2BIWnrQioS-tfQfOU4iDNAss3pzDKuNOPmSLWjNVP-zQrZJhZOK1Xf78TU9GdCSKnIApESyUZ777gjz7LC5PKw9Yk_NcNr8GCrKRsd7cCQciMf_sSmmZ1sqWKRcIAVWdt-B7_5fV9nW4vNfBYkFvJCI-BaIC_KmR-KPiVMUHi7y4hMzW1DmT4uzAJwfKIk3tvjWW6pEe345hE3R0nxqq-y0apP64DcndcDHFq16S1KqW465nsZRwvg6412LAjzp1cVM_XEimA9NekxAlTC1u89PNLyALrNtaaNRsAsj02D43lSFKu0gEKGMdAl23BhXkBtL-khwLYgoKWCbRkvZ7eznqnONx7zyGxxbNNU48Rn5NLDhw74Bxr0Xy72I1ROoGjm7E22V5-5BSl3CbsBAgczJ-fxCgxHzYWsmJpdqAIA6DVFmD5A8Vk=w690" alt="zeptojs" /></p>

<p>Zepto 是個跟 jQuery API 相容的套件，但是非常輕巧。</p>

<p>jQuery 1.11.2 不壓縮 278KB，壓縮後是 94.8KB。儘管 jQuery 2.0 比 jQuery 1.11 減少了 12% 的體積大小，仍然是個 200KB 級的套件。而 Zepto 不壓縮 56KB，壓縮後大約是 24.5KB，比 jQuery 平均小了 74%！</p>

<p>Zepto 極其輕巧的秘訣在於它預設只有 jQuery 最關鍵的幾個核心功能，並且用友善的模組化設計，保持每個功能能夠輕易地被擴充。</p>

<!-- more -->


<h2>擴充 animate 模組</h2>

<p>jQuery 的 <code>animate</code> 效能不是很好，上次在製作公司官網作品牆，讓圖片載完進行 <code>fadeIn</code> 的效果，造成 FPS 低到明顯感受到 lag。</p>

<p>通常需要用到大量的動態視覺效果的首選是 GreenSock 所提供的 TweenMax（344KB）。如果只是需要用來取代 jQuery 的 <code>animate</code> 操作 DOM 的動態效果，那麼能夠跟 jQuery 無縫整合的 Velocity（215KB）有更好的條件。Velocity 優點是效能高，體積比較小，也能夠相容 jQuery API。</p>

<p>Zepto 因為模組化設計的關係，預設是不包括 <code>animate</code> 這個方法的，因此便可以改用 Velocity 來擴充。</p>

<p>外部網站參考：</p>

<ul>
<li><a href="http://zeptojs.com/">Zepto 的專案網站</a></li>
<li><a href="http://julian.com/research/velocity/">Velocity 的專案網站</a></li>
<li><a href="https://greensock.com/tweenmax">TweenMax 的專案網站</a></li>
</ul>


<h2>瀏覽器相容性</h2>

<p>jQuery 2.0 開始就直接放棄 IE 9 以下的瀏覽器，Zepto 更狠直接跳到 IE 10+；而 Velocity 則是不支援 IE 8 以下，所以能不能使用 Zepto + Velocity 這個組合要先觀察一下產品的目標使用群。</p>

<p>如果打算支援 IE 8，還是去用 jQuery 1.11.3 吧！</p>
]]></content>
  </entry>
  
</feed>
