<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programing | @ChingHanHo]]></title>
  <link href="http://blog.chh.tw/blog/categories/programing/atom.xml" rel="self"/>
  <link href="http://blog.chh.tw/"/>
  <updated>2016-11-10T00:59:29+08:00</updated>
  <id>http://blog.chh.tw/</id>
  <author>
    <name><![CDATA[Ching-Han Ho]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SCSS 物件導向模組設計 (1)]]></title>
    <link href="http://blog.chh.tw/posts/scss-object-oriented/"/>
    <updated>2016-10-02T19:47:00+08:00</updated>
    <id>http://blog.chh.tw/posts/scss-object-oriented</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/mZCl_NgujdrKc-XhTqKsXA30gUb7dGQaQhe4Jjx8Blj4_97XWHoy5Zbfq6bk2GCu59jt0Gdu1Li8wCI3iCr9ejKu_wFJxzI4u6IrFl--RQ3KER-J0s4WXZ7f5VuQkH9Kc1TijUI6tHbGMdCt-r_fYO9wUI9ImbRlIhBTW4dgkg2YRDwIFbJjeMGWgQHBtjUb1dmsmjmKtcqWVPH5yfdnXxItyvLUCuA2zuN1dW90gljU6fdj5p1ivtoNQERUrJpXUhF0F_sDQcYsc2m9YzzOKvVnmvYDo0tUtmw1YzUts1PwrybI-G9c-7gKrc12Z_8PZl9dmF4GqOmi4c8ODPFFTxnZZGW5OYTGYah3LtiEQR8OzDY5HuOEKm2LUGPOLdBHRZVT-Xs6Ljy1cx6DLIAVPb1Q1SukfmDigXDyaLimn9-oEazRlugDF9Q2qStJaRzrsi2Ht6tnFZ8LK1XsTjgFpMh3mRnGQCKBewIjd7FiVnYGtT0f3XMhkSjv24UYW3gJAZuPLBjl4P8YQBW20ZLWQi33oCDxQKLr6MOLp-cx7YjOGSqfoYkAvcy3F08TyA2XAhV2PL_4g5gAqnETmUZOPmep9kHwy1gFL1eYJhTdLAcH982D-w=w1101-h755-no" alt="" /></p>

<p>三年前曾經寫過「<a href="http://blog.chh.tw/posts/oocss-smacss-and-css-guidelines/">劣以為的 OOCSS 和 SMACSS 以及其他 CSS 規範</a>」探討 OOCSS 模組化的方法論，時至今日對於模組化設計又有新的認識跟理解，大原則跟三年前的方法沒有出入，只是多做解釋跟補充。</p>

<p>OOCSS 物件導向是解釋設計原則，但是不限於語法的設計。</p>

<p>如果這個議題有興趣，歡迎繼續往下閱讀，如果有任何想法也歡迎留言與我討論！</p>

<!-- more -->


<p>這篇文章會解釋的內容，包括四個設計原則：</p>

<ul>
<li><a href="#srp">單一責任原則</a></li>
<li><a href="#lkp">極少化原則</a></li>
<li><a href="#isp">介面設計原則</a></li>
<li><a href="#ocp">開放封閉原則</a></li>
</ul>


<p>SCSS 模組化設計模式：</p>

<ul>
<li><a href="#cp">元件模式</a></li>
<li><a href="#sp">語義化模式</a></li>
</ul>


<hr />

<p><a name="srp"></a></p>

<h2>單一責任原則</h2>

<p>一個 class 只負責一件事情。這個原則不是指 <a href="https://github.com/marmelab/universal.css">universal.css</a> 這種設計方式，事實上這個專案是個反諷。單一責任原則是指職責獨立、目的明確的 class。</p>

<p>``` scss
.clearfix:before,
.clearfix:after {
  display: table;
  content: "";
}</p>

<p>.clearfix:after {
  clear: both;
}
```</p>

<p><a name="lkp"></a></p>

<h2>極少化原則</h2>

<p>對於層級的依賴應該盡可能減少。</p>

<p>多半的人剛開始寫 SCSS 都為它的巢狀語法感到著迷：</p>

<p>``` scss
.page {
  .content {</p>

<pre><code>.header {
  .inner {
    .group-list {
      .group-item {
        a {
          ...
        }
      }
    }
  }
}
</code></pre>

<p>  }
}
```</p>

<p>這個寫法有改善的空間，因為：</p>

<ul>
<li>不容易閱讀：當層級非常多的時候，哪段屬性屬於哪層 class 會看不清楚。</li>
<li>太倚賴 DOM 結構：一旦改變 DOM 層級結構，SCSS 也可能會需要做層級調整，層級越多耦合性越高，意味維護成本越高。</li>
</ul>


<p>改善的方式便是在相同的命名空間下，試著將層級攤平。適當使用巢狀語法的範例：</p>

<p>``` scss
.nav {
  list-style-type: none;
  margin: 0;</p>

<p>  li {</p>

<pre><code>display: inline-block;
</code></pre>

<p>  }</p>

<p>  a {</p>

<pre><code>display: block;
text-decoration: none;
color: blue;
</code></pre>

<p>  }
}
```</p>

<p>即便 <code>&lt;a&gt;</code> 的 DOM 結構是屬於 <code>&lt;li&gt;</code> 的子元素，仍然不影響它們的作用：</p>

<p>``` html</p>

<ul class="nav">
  <li><a href="...">...</a></li>
  <li><a href="...">...</a></li>
  <li><a href="...">...</a></li>
</ul>


<p>```</p>

<p>有時候與 DOM 元素本身有絕對關聯的 class，可以在使用區塊註解加以說明：</p>

<p><code>scss
/* ul */.nav {
  ...
}
</code></p>

<p><a name="isp"></a></p>

<h2>介面設計原則</h2>

<p>針對介面設計，而不是針對實踐方式設計。這個原則可以減少重複的程式碼，增加可維護性。</p>

<p>例如兩個有著相似樣式的區塊，往往會針對區塊實踐它們各別的樣式：</p>

<p>``` scss
.card-default {
  border: 1px solid hsla(0, 0%, 33%, 0.85);
  padding: 15px;
}</p>

<p>.card-primary {
  border: 1px solid hsla(0, 0%, 66%, 1);
  padding: 20px;
}
```</p>

<p>``` html</p>

<div class="card-default">
  ...
</div>




<div class="card-primary">
  ...
</div>


<p>```</p>

<p>應該先設計這個模組的介面（interface），再依照介面實踐它不同的樣式特性：</p>

<p>``` scss
// 先設計介面
.card {
  border: 1px solid transparent;
  padding: 10px;
}</p>

<p>// 再實踐不同的介面樣式
.card-default {
  border-color: hsla(0, 0%, 33%, 0.85);
  padding: 15px;
}</p>

<p>.card-primary {
  border-color: hsla(0, 0%, 66%, 1);
  padding: 20px;
}
```</p>

<p>``` html</p>

<div class="card card-default">
  ...
</div>




<div class="card card-primary">
  ...
</div>


<p>```</p>

<p>一旦先有了介面，後續也才能夠知道該怎麼對此模組進行擴充。</p>

<p><a name="ocp"></a></p>

<h2>開放封閉原則</h2>

<p>對修改封閉、對擴充開放。除非是根本性上地調整模組的樣式，才會需要去改動到介面層級的樣式。這裡引用上一則原則的範例：</p>

<p>``` scss
.card {
  border: 1px solid transparent;
  padding: 10px;
}</p>

<p>.card-default {
  border-color: hsla(0, 0%, 33%, 0.85);
  padding: 15px;
}
```</p>

<p>``` html</p>

<div class="card card-default">
  ...
</div>


<p>```</p>

<p>當某個頁面需要對此介面做特殊調整，可以使用開放封閉原則，對此介面進行擴充，而不會影響到其他頁面樣式：</p>

<p><code>scss
.card-users {
  border-color: hsla(0, 0%, 100%, 1);
}
</code></p>

<p>``` html</p>

<div class="card card-default card-users">
  ...
</div>


<p>```</p>

<hr />

<p><a name="cp"></a></p>

<h2>元件模式</h2>

<p>元件模式的哲學在於 class 本身與語義化無關，應該關注它們是否合理，不要刻意強調 class 名稱要符合語義，而要注重使用的合理性與未來性。例如：子元素區塊使用 <code>.list-item</code> 上層元素使用 <code>.list-group</code> 作為子元素的集合，這與元素本身是否是個序列清單（<code>&lt;ol&gt;</code> ）無關。</p>

<p>在前面瞭解過四大設計原則之後，現在已經可以很輕易地設計出模組。先設計介面（interface），再實踐不同的模組樣式：</p>

<p>``` scss
.card {
  background-color: transparent;
}</p>

<p>.card-default {
  background-color: white;
}</p>

<p>.card-primary {
  background-color: red;
}
```</p>

<p>在 HTML 上的使用方式：</p>

<p>``` html</p>

<div class="card card-default">...</div>


<div class="card card-primary">...</div>


<p>```</p>

<p>元件模式好處在於開發前端版型，只需要專注在刻寫 HTML 上，快速調用各種模組 class 名稱、減少花時間替 class 命名的 context switch 成本。缺點亦即很容易過度膨脹 HTML 體積，例如使用熱門框架 <a href="http://getbootstrap.com/">Bootstrap</a> 的人們應該對此都不陌生：</p>

<p>``` html</p>

<div class="col-lg-9 col-md-9 col-sm-9 col-xs-12 col-lg-offset-3 col-md-offset-3 col-sm-offset-3">
  ...
</div>


<p>```</p>

<p><a name="sp"></a></p>

<h2>語義化模式</h2>

<p>語義化強調元素本身所代表的意義，但並非漫無目的地設計 class；結合四種模組設計原則，加上 SCSS 語法的便利性，可以很容易地設計出容易維護及擴充的模組：</p>

<p>``` scss
card {
  @at-root {</p>

<pre><code>%#{&amp;} {
  background-color: transparent;
}

%#{&amp;}-default {
 background-color: white;
}

%#{&amp;}-primary {
  background-color: red;
}
</code></pre>

<p>  }
}</p>

<p>.content {
  @extend %card;
  @extend %card-default;
}</p>

<p>.sidebar {
  @extend %card;
  @extend %card-primary;
}
```</p>

<p>這會產生出以下的結果：</p>

<p>``` scss
.content,
.sidebar {
  background-color: transparent;
}</p>

<p>.content {
  background-color: white;
}</p>

<p>.sidebar {
  background-color: red;
}
```</p>

<p>因此可以清晰、明確地定義出區塊所代表的意義：</p>

<p>``` html</p>

<div class="sidebar">...</div>


<div class="content">...</div>


<p>```</p>

<p>語義化模式的優點在於減少 HTML 冗長的 class 名稱串聯，透過 SCSS 語法優勢，對不同的區塊套入相同的模組樣式。缺點在於切出每個區塊時沒有那麼容易替其命名，增加了中間「做決定」的思考成本。</p>

<p>兩個模式並非相互衝突，可以在適當的時機交互結合應用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用一個 HTML 樣版引擎的選擇重點]]></title>
    <link href="http://blog.chh.tw/posts/how-to-select-html-template-engines/"/>
    <updated>2016-07-22T15:02:00+08:00</updated>
    <id>http://blog.chh.tw/posts/how-to-select-html-template-engines</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/QgvDvJX1TZztm_lBHTgAD2gEhw89v82uk9DVs1l69GlRVlSQ_fRxQ_WiNk54B-iUbyPB7AoUm2ZoBpHUD3cN99AHB6VTcSVUG24zeEypIKoWgk9cUnbnPMHsvmU5eoBjjQSBKaPBitjKvu82xnqYL5Gm0mMlU8OAzHcmh3_WxZx8EUsqB-roXuFp31zGkW84Z4JY3l01F6mPK6vTss_Xdg707k0y4lo0OX8mUnETc196rK2L5-y1clcgvLB33qvaBAHQq6JOqbuOmcV3_qbJb-NDC714KqTB-R6m15KBcTYk_72s8rUUOTKDGjDpsm-nVIGdwxJAjYICl8Cz7mB_c9pVeRKdx17ennNpyhUrK1JYuWAk4Gk9wPQv3_lt8PuxrvUMZwwkranlg1Ob0MB6XuQSn2MFaEGU1XFbgAOMZ6iPKjxceKupt9bE5aPevLjMk_O_WvKQAAzwg7Ne8BK_tUrmHWbYwvhUUpcwV-sKSsCFrE4Ps31LvgxqMWQ-c_Z0iq7Ou5WFWfc2eDrx_JWptmkTeWDfBmjo9uVuusVuXjy4g1G-GpSUIhU8ZYTBlKZZJA3dFRwevNTOmlC_hsFL8kgcfqbm_SXP=w1101-h493-no" alt="" /></p>

<h3>語法</h3>

<p>首先當然是要喜歡上該樣版引擎的語法，因為使用樣版引擎的主要目的就是為了加速撰寫 HTML 的生產力，給先讓自己喜歡使用它，才有辦法寫得有效率。多數樣版引擎的入口頁會用簡單的範例，快速火力展示它的特點，這是很好的開始。但也因為這是精心設計的著陸頁，目的是攻取心裡的小惡魔，所以在選擇採用這套樣版引擎前也得特別小心。</p>

<h3>擴充性</h3>

<p>一個好的樣版引擎可以讓自己掌控專案的伸縮性，例如註冊新的 helper 跟 block，節省撰寫重複的程式碼，靈活地設計版型架構。</p>

<h3>安全性</h3>

<p>對於經驗不足的開發者來說這很容易鑄成大錯，在沒有意識下的輸出未消毒的內容，都可能會造成使用者傷害，而一個好的樣版引擎應該要預設消毒輸出。如果對自己的經驗很有信心，覺得這是初學者才會犯的錯誤，但也不能夠保證其他同事們不會粗心大意。</p>

<h3>勿矯枉過正</h3>

<p>使用樣版引擎是為了增加團隊在撰寫 HTML 的效率，所以應該以團隊的技術水平作為優先考量，如果團隊的平均技術水平沒有達到而貿然採用也只是增加大家困擾而已。 不要為了使用而使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Zepto + Velocity 無縫取代 jQuery 更輕巧]]></title>
    <link href="http://blog.chh.tw/posts/using-zepto-replace-jquery/"/>
    <updated>2015-10-01T00:26:00+08:00</updated>
    <id>http://blog.chh.tw/posts/using-zepto-replace-jquery</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/fKcLfP4rJK5syiKv-cfmDYlbdC0_dV8sAdyQfYM3DxZW76knVkgxFsMC4sWsBpaN_27emoOHF504CNpmSDn0rnlDG2Eu1vw6RNowi18owUxdnBYaotT3hz2BIWnrQioS-tfQfOU4iDNAss3pzDKuNOPmSLWjNVP-zQrZJhZOK1Xf78TU9GdCSKnIApESyUZ777gjz7LC5PKw9Yk_NcNr8GCrKRsd7cCQciMf_sSmmZ1sqWKRcIAVWdt-B7_5fV9nW4vNfBYkFvJCI-BaIC_KmR-KPiVMUHi7y4hMzW1DmT4uzAJwfKIk3tvjWW6pEe345hE3R0nxqq-y0apP64DcndcDHFq16S1KqW465nsZRwvg6412LAjzp1cVM_XEimA9NekxAlTC1u89PNLyALrNtaaNRsAsj02D43lSFKu0gEKGMdAl23BhXkBtL-khwLYgoKWCbRkvZ7eznqnONx7zyGxxbNNU48Rn5NLDhw74Bxr0Xy72I1ROoGjm7E22V5-5BSl3CbsBAgczJ-fxCgxHzYWsmJpdqAIA6DVFmD5A8Vk=w690" alt="zeptojs" /></p>

<p>Zepto 是個跟 jQuery API 相容的套件，但是非常輕巧。</p>

<p>jQuery 1.11.2 不壓縮 278KB，壓縮後是 94.8KB。儘管 jQuery 2.0 比 jQuery 1.11 減少了 12% 的體積大小，仍然是個 200KB 級的套件。而 Zepto 不壓縮 56KB，壓縮後大約是 24.5KB，比 jQuery 平均小了 74%！</p>

<p>Zepto 極其輕巧的秘訣在於它預設只有 jQuery 最關鍵的幾個核心功能，並且用友善的模組化設計，保持每個功能能夠輕易地被擴充。</p>

<!-- more -->


<h2>擴充 animate 模組</h2>

<p>jQuery 的 <code>animate</code> 效能不是很好，上次在製作公司官網作品牆，讓圖片載完進行 <code>fadeIn</code> 的效果，造成 FPS 低到明顯感受到 lag。</p>

<p>通常需要用到大量的動態視覺效果的首選是 GreenSock 所提供的 TweenMax（344KB）。如果只是需要用來取代 jQuery 的 <code>animate</code> 操作 DOM 的動態效果，那麼能夠跟 jQuery 無縫整合的 Velocity（215KB）有更好的條件。Velocity 優點是效能高，體積比較小，也能夠相容 jQuery API。</p>

<p>Zepto 因為模組化設計的關係，預設是不包括 <code>animate</code> 這個方法的，因此便可以改用 Velocity 來擴充。</p>

<p>外部網站參考：</p>

<ul>
<li><a href="http://zeptojs.com/">Zepto 的專案網站</a></li>
<li><a href="http://julian.com/research/velocity/">Velocity 的專案網站</a></li>
<li><a href="https://greensock.com/tweenmax">TweenMax 的專案網站</a></li>
</ul>


<h2>瀏覽器相容性</h2>

<p>jQuery 2.0 開始就直接放棄 IE 9 以下的瀏覽器，Zepto 更狠直接跳到 IE 10+；而 Velocity 則是不支援 IE 8 以下，所以能不能使用 Zepto + Velocity 這個組合要先觀察一下產品的目標使用群。</p>

<p>如果打算支援 IE 8，還是去用 jQuery 1.11.3 吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9 個存取硬體裝置的 Javascript API]]></title>
    <link href="http://blog.chh.tw/posts/9-javascript-apis-accessing-device-sensors/"/>
    <updated>2015-08-30T17:09:00+08:00</updated>
    <id>http://blog.chh.tw/posts/9-javascript-apis-accessing-device-sensors</id>
    <content type="html"><![CDATA[<p>原生 HTML5 和 Javascript API 可以直接從瀏覽器存取硬體組件和感測器。這裏的硬體裝置主要是指手機。</p>

<h3>點擊連結傳送簡訊</h3>

<p>``` html
<a href="tel:0912345678">打給我！</a></p>

<!-- Android -->


<p><a href="sms:0912345678?body=你到哪了？">傳簡訊給我！</a></p>

<!-- iOS -->


<p><a href="sms:0912345678&amp;body=你到哪了？">傳簡訊給我！</a>
```</p>

<p>延伸資料：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/6480462/how-to-pre-populate-the-sms-body-text-via-an-html-link">How to pre-populate the sms body text via an html link - StackOverflow</a></li>
</ul>


<h3>地理定位 API</h3>

<p>``` js
if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(function (position) {</p>

<pre><code>var whereareyou = position.coords.latitude + ' ,' + position.coords.longitude
alert(whereareyou)
</code></pre>

<p>  })
}
```</p>

<h3>裝置方向與裝置體感 API</h3>

<p>這兩個功能是建立在裝置的陀螺儀和指南針感測器上，它能夠傳回目前裝置的旋轉角度，以及三個維度。</p>

<p>``` js
if (window.DeviceOrientationEvent) {
  window.addEventListener('deviceorientation', function(event) {</p>

<pre><code>// gamma 是左到右傾斜的角度
// beta  是前到後傾斜的角度
// alpha 是裝置面向在指南針方位上的角度
document.body.innerHTML = event.gamma + ' ,' + event.beta + ' ,' + event.alpha
</code></pre>

<p>  }, false)
}
```</p>

<p>有了裝置體感的 API，也可以做出搖一搖復原輸入的功能。</p>

<p>``` js
if (window.DeviceMotionEvent) {
  window.addEventListener('devicemotion', function(evnet) {</p>

<pre><code>document.body.innerHTML = evnet.acceleration.x + '&lt;br/&gt;' + evnet.acceleration.y + '&lt;br/&gt;' + evnet.acceleration.z

// 加速感測
console.log(evnet.acceleration.x)
console.log(evnet.acceleration.y)
console.log(evnet.acceleration.z)

// 加速感測包括重力參數
console.log(evnet.accelerationIncludingGravity.x)
console.log(evnet.accelerationIncludingGravity.y)
console.log(evnet.accelerationIncludingGravity.z)

// 旋轉率
console.log(evnet.rotationRate.alpha)
console.log(evnet.rotationRate.beta)
console.log(evnet.rotationRate.gamma)
</code></pre>

<p>  }, false)
}
```</p>

<p>延伸資料：</p>

<ul>
<li><a href="https://developers.google.com/web/fundamentals/device-access/device-orientation/dev-motion?hl=zh-tw">裝置動作 - Web Fundamentals</a></li>
<li><a href="https://developers.google.com/web/fundamentals/device-access/device-orientation/?hl=zh-tw">裝置定向 - Web Fundamentals</a></li>
</ul>


<h3>震動馬達</h3>

<p>目前只支援 Android 的 Chrome 以及 Opera、Firefox，iOS 尚不支援。</p>

<p><code>js
var btn = document.getElementById('btn')
var vibrate = navigator.vibrate || navigator.mozVibrate || navigator.webkitVibrate
btn.addEventListener('click', function (event) {
  vibrate(1000)
})
</code></p>

<p>延伸資料：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate">Navigator.vibrate() - MDN</a></li>
</ul>


<h3>剩餘電力管理</h3>

<p>``` js
var battery = navigator.battery || navigator.webkitBattery || navigator.mozBattery</p>

<p>function log(<em>battery) {
  document.body.innerHTML = '目前電力剩下：' + (</em>battery.level * 100) + '%'
  _battery.addEventListener('chargingchange', function() {</p>

<pre><code>alert('開始充電！')
</code></pre>

<p>  }, false)
}</p>

<p>if (navigator.getBattery) {
  navigator.getBattery().then(log)
} else if (battery) {
  log(battery)
}
```</p>

<h3>亮度感測器</h3>

<p>目前只有 Firefox 支援這個 API。</p>

<p><code>js
if ('ondevicelight' in window) {
  window.addEventListener("devicelight", function (event) {
  // 回傳的是亮度單位 lux
  console.log(event.value + " lux")
  })
}
</code></p>

<h3>近距離感測 API</h3>

<p>這個也是只有 Firefox 支援。</p>

<p>``` js
if('ondeviceproximity' in window) {
  // Fired when object is in the detection zone
  window.addEventListener('deviceproximity', function (event) {</p>

<pre><code>  // Object distance in centimeters
  console.log(event.value + " centimeters")
})
</code></pre>

<p>} else {
  console.log("deviceproximity not supported")
}</p>

<p>if('ondeviceproximity' in window){
  // Fired when object is in the detection zone
  window.addEventListener('userproximity', function (event) {</p>

<pre><code>if(event.near == true) {
  console.log("Object is near")
} else {
  console.log("Object is far")
}
</code></pre>

<p>  })
} else {
  console.log("userproximity not supported")
}
```</p>

<hr />

<p>參考：</p>

<ul>
<li><a href="http://www.webondevices.com/9-javascript-apis-accessing-device-sensors/">9 JavaScript APIs accessing Device Hardware</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[io.js 1.1 VS node.js 0.12.0 VS node.js 0.10.36]]></title>
    <link href="http://blog.chh.tw/posts/iojs-nodejs-performance/"/>
    <updated>2015-02-10T23:37:00+08:00</updated>
    <id>http://blog.chh.tw/posts/iojs-nodejs-performance</id>
    <content type="html"><![CDATA[<p>這篇文章不是要做深入的效能評比，只是最近 node.js v0.12.0 正式版釋出，又剛好人品很好地用 io.js 1.1 把專案建起來了，乾脆就在本機上做一下 node.js 新舊版和現在很熱的 io.js 效能紀錄。圖有點小，要嘛自己想辦法放大，要嘛就直接看結論吧！XD</p>

<h3>Page 1</h3>

<p><img src="https://lh3.googleusercontent.com/-AWI4LN6fELs/VNomvCU_iMI/AAAAAAAAIKs/Im1igPcG3EI/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.28.59%2BPM.png" alt="node.js v0.12.0 page1" /></p>

<p>node.js v0.12.0 TTFB 1.36s。</p>

<p><img src="https://lh6.googleusercontent.com/-tl-PFTsvs-0/VNomy_t_IkI/AAAAAAAAILU/YRiVxSVD5Dc/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.34.28%2BPM.png" alt="io.js v1.1.0 page1" /></p>

<p>io.js v1.1.0 TTFB 1.21s。</p>

<p><img src="https://lh4.googleusercontent.com/-pJ4XM3ov8v4/VNomx2fPf-I/AAAAAAAAILE/RxH-DOoQygg/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.30.32%2BPM.png" alt="node.js v0.10.36 page1" /></p>

<p>node.js v0.10.36 TTFB 603ms。</p>

<!-- more -->


<h3>Page 2</h3>

<p><img src="https://lh4.googleusercontent.com/-5LGXJ2DInfM/VNomvEBYaQI/AAAAAAAAIK0/UyWZldWsB-4/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.29.22%2BPM.png" alt="node.js v0.12.0 page2" /></p>

<p>node.js v0.12.0 TTFB 910ms。</p>

<p><img src="https://lh3.googleusercontent.com/-CePlsRGHndI/VNomzP3ZMzI/AAAAAAAAILc/YlkhDkjRHAY/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.34.49%2BPM.png" alt="io.js v1.1.0 page2" /></p>

<p>io.js v1.1.0 TTFB 776ms。</p>

<p><img src="https://lh5.googleusercontent.com/-AemhYmtokBw/VNomx8aIBMI/AAAAAAAAILg/3GBjTwsTs1w/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.30.43%2BPM.png" alt="node.js v0.10.36 page2" /></p>

<p>node.js v0.10.36 TTFB 604ms。</p>

<h3>Page 3</h3>

<p><img src="https://lh3.googleusercontent.com/-sbjgcsYBKEI/VNomvAQ99yI/AAAAAAAAIKw/1kKSgNjzysw/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.29.37%2BPM.png" alt="node.js v0.12.0 page3" /></p>

<p>node.js v0.12.0 TTFB 221ms。</p>

<p><img src="https://lh4.googleusercontent.com/-D1D5stJUzPg/VNomxwPjWOI/AAAAAAAAILI/Zj_XEEIcOxs/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.30.51%2BPM.png" alt="node.js v0.10.36 page3" /></p>

<p>io.js v1.1.0 TTFB 217ms。</p>

<p><img src="https://lh3.googleusercontent.com/-ZnrOiohW9VU/VNomzm0vZCI/AAAAAAAAILk/cT8R99I1tJc/w1118-h331-no/Screen%2BShot%2B2015-02-10%2Bat%2B11.35.08%2BPM.png" alt="io.js v1.1.0 page3" /></p>

<p>node.js v0.10.36 TTFB 150ms。</p>

<h3>結論</h3>

<p>每個頁面我都土法重複 reload 過好幾次，大概抓的數字是看到的平均值，想說這樣的測試太土法了，沒參考性，但是三個頁面的測試結果彼此比較後都很相像，所以應該可以說明什麼了吧！</p>

<ul>
<li>node.js v0.12.0 TTFB 1.36s +0%</li>
<li>io.js v1.1.0 TTFB 1.21s +12%</li>
<li>node.js v0.10.36 TTFB 603ms +126%</li>
</ul>


<p>頁面一舊版 node.js v0.10.36 比其他兩頁都快得多！跟 io.js v1.1.0 比起來也快了至少 100%。</p>

<ul>
<li>node.js v0.12.0 TTFB 910ms +0%</li>
<li>io.js v1.1.0 TTFB 776ms +17%</li>
<li>node.js v0.10.36 TTFB 604ms +51%</li>
</ul>


<p>頁面二也是 node.js v0.10.36 最快。</p>

<ul>
<li>node.js v0.12.0 TTFB 221ms +0%</li>
<li>io.js v1.1.0 TTFB 217ms +1.8%</li>
<li>node.js v0.10.36 TTFB 150ms +47%</li>
</ul>


<p>頁面三其實都相差不遠，但 node.js v0.10.36 仍然反應最快。</p>

<p>結論就是……等網站上到遠端 server 之後再來測一次真實網路環境下的 TTFB 吧！以目前在本機測試的結果，還沒有很想更新到 node.js v0.12.0，而且以<a href="http://blog.chh.tw/posts/what-is-iojs-nodejs-forking/">現在這局勢</a>看來 io.js 勢頭很高，再過一段時間來評估直接把專案跳去改用 io.js 算了。:p</p>
]]></content>
  </entry>
  
</feed>
